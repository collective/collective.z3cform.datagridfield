{"version":3,"file":"chunks/15.ecd89a58c49bdc962eb9.min.js","mappings":"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","sources":["webpack://collective-z3cform-datagridfield/./resources/js/datagridfield.pattern.js","webpack://collective-z3cform-datagridfield/./resources/datagridfield-config.js"],"sourcesContent":["// Layout Mosaic pattern.\nimport \"regenerator-runtime/runtime\"; // needed for ``await`` support\nimport $ from \"jquery\";\nimport Base from \"@patternslib/patternslib/src/core/base\";\nimport Registry from \"@patternslib/patternslib/src/core/registry\";\nimport logging from \"@patternslib/patternslib/src/core/logging\";\n\nlogging.setLevel(\"INFO\");\nconst log = logging.getLogger(\"datagridfield\");\n\n\nexport default Base.extend({\n    name: \"datagridfield\",\n    trigger: \".pat-datagridfield\",\n    parser: \"mockup\",\n\n    init: function () {\n        import(\"../scss/datagridfield.scss\");\n\n        // - Make sure, at least one empty row is always shown.\n        // - Auto append a new row when editing the last row.\n\n        this.el = this.$el[0];\n        this.el_body = this.el.querySelector(\".datagridwidget-body\");\n\n        this.auto_append = (this.el.dataset.autoAppend || \"true\").toLowerCase() !== \"false\"; // prettier-ignore\n\n        this._defineHandler();\n\n        // Before ensureMinimumRows, as creating a row initializes row ui again.\n        this.getVisibleRows().forEach(function (row) {\n            this.initRowUI(row);\n        }, this);\n\n        if (!this.ensureMinimumRows()) {\n            // If ensureMinimumRows returned true, it already did the update.\n            this.updateOrderIndex();\n        }\n        this.initAutoAppendHandler();\n\n        this.el.dispatchEvent(\n            new Event(\"afterdatagridfieldinit\", {\n                bubbles: true,\n                cancelable: true,\n            })\n        );\n    },\n\n    _defineHandler: function () {\n        // Store event handler which also has to be removed, so we can detach it.\n        // See: https://stackoverflow.com/a/10444156/1337474 , also comment about \"bind\"\n        // using ``bind`` will change the function signature too.\n\n        this.handler_auto_append = function (e) {\n            if (e) {\n                e.stopPropagation();\n            }\n            // Also allow direct call without event.\n            if (e && !e.target.closest(\".datagridwidget-cell\")) {\n                return;\n            }\n            this.auto_append_row();\n        }.bind(this);\n\n        this.handler_auto_append_input = function (e) {\n            var row = e.currentTarget;\n            row.classList.remove(\"auto-append\");\n            row.dataset.oldIndex = row.dataset.index; // store for replacing.\n            delete row.dataset.index; // remove \"AA\" index\n            this.updateOrderIndex();\n            row.removeEventListener(\n                \"input\",\n                this.handler_auto_append_input\n            );\n        }.bind(this);\n    },\n\n    initRowUI: function (row) {\n        row.querySelectorAll(\".dgf--row-add\").forEach(function (el) {\n            el.addEventListener(\n                \"click\",\n                function (e) {\n                    e.preventDefault();\n                    this.insertRow(row);\n                    this.updateOrderIndex();\n                }.bind(this)\n            );\n        }, this);\n\n        row.querySelectorAll(\".dgf--row-delete\").forEach(function (el) {\n            el.addEventListener(\n                \"click\",\n                function (e) {\n                    e.preventDefault();\n                    e.stopPropagation();\n                    this.removeFieldRow(row);\n                }.bind(this)\n            );\n        }, this);\n\n        row.querySelectorAll(\".dgf--row-moveup\").forEach(function (el) {\n            el.addEventListener(\n                \"click\",\n                function (e) {\n                    e.preventDefault();\n                    this.moveRowUp(row);\n                }.bind(this)\n            );\n        }, this);\n\n        row.querySelectorAll(\".dgf--row-movedown\").forEach(function (el) {\n            el.addEventListener(\n                \"click\",\n                function (e) {\n                    e.preventDefault();\n                    this.moveRowDown(row);\n                }.bind(this)\n            );\n        }, this);\n    },\n\n    get_row_buttons: function (row) {\n        return {\n            add: row.querySelector(\".dgf--row-add\"),\n            delete: row.querySelector(\".dgf--row-delete\"),\n            up: row.querySelector(\".dgf--row-moveup\"),\n            down: row.querySelector(\".dgf--row-movedown\"),\n        };\n    },\n\n    setUIState: function () {\n        var rows = this.getVisibleRows();\n        for (var cnt = 0; cnt < rows.length; cnt++) {\n            var row = rows[cnt];\n            var buttons = this.get_row_buttons(row);\n\n            if (this.auto_append === true && row.dataset.index === \"AA\") {\n                // Special case AA\n\n                if (buttons.add) {\n                    buttons.add.disabled = true;\n                }\n                if (buttons.delete) {\n                    buttons.delete.disabled = true;\n                }\n                if (buttons.up) {\n                    buttons.up.disabled = true;\n                }\n                if (buttons.down) {\n                    buttons.down.disabled = true;\n                }\n                if (cnt > 0) {\n                    // Set the previous buttons also, if available.\n                    var before_aa_buttons = this.get_row_buttons(\n                        rows[cnt - 1]\n                    );\n                    if (before_aa_buttons.down) {\n                        before_aa_buttons.down.disabled = true;\n                    }\n                }\n            } else if (cnt === 0) {\n                // First row\n\n                if (buttons.add) {\n                    buttons.add.disabled = false;\n                }\n                if (buttons.delete) {\n                    buttons.delete.disabled = false;\n                }\n                if (buttons.up) {\n                    buttons.up.disabled = true;\n                }\n                if (buttons.down) {\n                    buttons.down.disabled = rows.length === 1; // disable if 1 row.\n                }\n            } else if (cnt === rows.length - 1) {\n                // Last button - if no AA buttons.\n                // Also, if this is reached, it's not the only row.\n\n                if (buttons.add) {\n                    buttons.add.disabled = false;\n                }\n                if (buttons.delete) {\n                    buttons.delete.disabled = false;\n                }\n                if (buttons.up) {\n                    buttons.up.disabled = false;\n                }\n                if (buttons.down) {\n                    buttons.down.disabled = true;\n                }\n            } else {\n                // Normal in-between case.\n\n                if (buttons.add) {\n                    buttons.add.disabled = false;\n                }\n                if (buttons.delete) {\n                    buttons.delete.disabled = false;\n                }\n                if (buttons.up) {\n                    buttons.up.disabled = false;\n                }\n                if (buttons.down) {\n                    buttons.down.disabled = false;\n                }\n            }\n        }\n    },\n\n    getRows: function () {\n        // Return primary nodes with class of datagridwidget-row, they can be any tag: tr, div, etc.\n        return this.el_body.querySelectorAll(\".datagridwidget-row\");\n    },\n\n    getVisibleRows: function () {\n        return this.el_body.querySelectorAll(\n            \".datagridwidget-row:not([data-index=TT])\"\n        );\n    },\n\n    getLastRow: function () {\n        return this.el_body.querySelector(\".datagridwidget-row:last-child\");\n    },\n\n    getLastVisibleRow: function () {\n        var result = this.el_body.querySelectorAll(\n            \".datagridwidget-row:not([data-index=TT])\"\n        );\n        return result[result.length - 1];\n    },\n\n    countRows: function () {\n        var count = 0;\n        this.getRows().forEach(function (row) {\n            // do not include the TT and the AA rows in the count\n            if ([\"AA\", \"TT\"].indexOf(row.dataset.index) === -1) {\n                count++;\n            }\n        }, this);\n        return count;\n    },\n\n    initAutoAppendHandler: function () {\n        if (!this.auto_append) {\n            return;\n        }\n\n        this.getVisibleRows().forEach(function (row) {\n            row.removeEventListener(\"focusout\", this.handler_auto_append);\n        }, this);\n\n        var last_row = this.getLastVisibleRow();\n        if (last_row) {\n            last_row.addEventListener(\"focusout\", this.handler_auto_append);\n        }\n    },\n\n    auto_append_row: function () {\n        this.el.dispatchEvent(new Event(\"beforeaddrowauto\"));\n        this.getVisibleRows().forEach(function (row) {\n            row.classList.remove(\"auto-append\");\n            if (row.dataset.index !== \"TT\") {\n                // actually, getVisibleRows should only return non-\"TT\"\n                // rows, but to be clear here...\n                // delete the index, we're setting it in updateOrderIndex again.\n                row.dataset.oldIndex = row.dataset.index; // store for replacing.\n                delete row.dataset.index;\n            }\n        });\n        var last_row = this.getLastVisibleRow() || this.getLastRow();\n        var new_row = this.insertRow(last_row);\n        new_row.classList.add(\"auto-append\");\n        this.reindexRow(new_row, \"AA\");\n        this.updateOrderIndex();\n        new_row.addEventListener(\"input\", this.handler_auto_append_input);\n        this.el.dispatchEvent(new Event(\"afteraddrowauto\"));\n    },\n\n    insertRow: function (ref_row, before) {\n        /**\n         * Add a new row when changing the last row\n         *\n         * @param {DOM node} ref_row insert row after this one.\n         */\n\n        // Create a new row\n        var newtr = this.createNewRow();\n        var $newtr = $(newtr);\n\n        /* Put new row to DOM tree after our current row.  Do this before\n            * reindexing to ensure that any Javascript we insert that depends on\n            * DOM element IDs (such as plone.formwidget.autocomplete) will\n            * pick up this row before any IDs get changed.  At this point,\n            * we techinically have duplicate TT IDs in our document\n            * (one for this new row, one for the hidden row), but jQuery\n            * selectors will pick up elements in this new row first.\n            */\n\n        this.$el.trigger(\"beforeaddrow\", [this.$el, $newtr]);\n\n        if (before) {\n            $newtr.insertBefore(ref_row);\n        } else {\n            $newtr.insertAfter(ref_row);\n        }\n\n        this.initRowUI(newtr);\n        Registry.scan($newtr);\n\n        this.initAutoAppendHandler();\n\n        this.$el.trigger(\"afteraddrow\", [this.$el, $newtr]);\n\n        return newtr;\n    },\n\n    createNewRow: function () {\n        /**\n         * Creates a new row.\n         *\n         * The row is not inserted to the table, but is returned.\n         */\n\n        // hidden template row\n        var template_row = this.el_body.querySelector(\"[data-index=TT]\");\n        if (!template_row) {\n            throw new Error(\"Could not locate empty template row in DGF\");\n        }\n\n        var new_row = document.createElement(\"table\");\n        new_row.innerHTML = template_row.outerHTML;\n        new_row = new_row.querySelector(\"tr\");\n\n        new_row.dataset.oldIndex = new_row.dataset.index; // store for replacing.\n        delete new_row.dataset.index; // fresh row.\n        new_row.classList.remove(\"datagridwidget-empty-row\");\n\n        var $new_row = $(new_row);\n        // enable patternslib\n        $new_row\n            .find('*[class^=\"dgw-disabled-pat-\"]')\n            .attr(\"class\", function (i, cls) {\n                return cls.replace(/dgw\\-disabled-pat-/, \"pat-\");\n            });\n        return new_row;\n    },\n\n    removeFieldRow: function (row) {\n        /* Remove the row in which the given node is found */\n        $(row).remove();\n\n        if (!this.ensureMinimumRows()) {\n            // If ensureMinimumRows returned true, it already did the update.\n            this.updateOrderIndex();\n        }\n        this.updateOrderIndex();\n        this.initAutoAppendHandler();\n    },\n\n    moveRowDown: function (row) {\n        this.moveRow(row, \"down\");\n        this.updateOrderIndex();\n        this.initAutoAppendHandler();\n    },\n\n    moveRowUp: function (row) {\n        this.moveRow(row, \"up\");\n        this.updateOrderIndex();\n        this.initAutoAppendHandler();\n    },\n\n    moveRowToTop: function (row) {\n        var rows = this.getRows();\n        $(row).insertBefore(rows[0]);\n        this.updateOrderIndex();\n        this.initAutoAppendHandler();\n    },\n\n    moveRowToBottom: function (row) {\n        var rows = this.getRows();\n\n        // make sure we insert the directly above any auto appended rows\n        var insert_after = 0;\n        $(rows).each(function (i, _row) {\n            if ([\"AA\", \"TT\"].indexOf(_row.dataset.index) === -1) {\n                insert_after = i;\n            }\n        });\n        $(row).insertAfter(rows[insert_after]);\n        this.updateOrderIndex();\n        this.initAutoAppendHandler();\n    },\n\n    moveRow: function (row, direction) {\n        /* Move the given row down one */\n        var nextRow;\n        var rows = this.getRows();\n        var idx = null;\n\n        // We can't use nextSibling because of blank text nodes in some browsers\n        // Need to find the index of the row\n        $(rows).each(function (i, _row) {\n            if (row === _row) {\n                idx = i;\n            }\n        });\n\n        // Abort if the current row wasn't found\n        if (idx === null) {\n            return;\n        }\n\n        // The up and down should cycle through the rows, excluding the auto-append and\n        // empty-row rows.\n        var validrows = this.countRows();\n\n        if (idx + 1 == validrows) {\n            if (direction == \"down\") {\n                this.moveRowToTop(row);\n            } else {\n                nextRow = rows[idx - 1];\n                this.shiftRow(nextRow, row);\n            }\n        } else if (idx === 0) {\n            if (direction == \"up\") {\n                this.moveRowToBottom(row);\n            } else {\n                nextRow = rows[parseInt(idx + 1, 10)];\n                this.shiftRow(row, nextRow);\n            }\n        } else {\n            if (direction == \"up\") {\n                nextRow = rows[idx - 1];\n                this.shiftRow(nextRow, row);\n            } else {\n                nextRow = rows[parseInt(idx + 1, 10)];\n                this.shiftRow(row, nextRow);\n            }\n        }\n        this.$el.trigger(\"aftermoverow\", [this.$el, row]);\n    },\n\n    shiftRow: function (bottom, top) {\n        /* Put node top before node bottom */\n        $(top).insertBefore(bottom);\n    },\n\n    reindexRow: function (row, new_index) {\n        /**\n         * Fixup all attributes on all child elements that contain\n         * the row index. The following attributes are scanned:\n         * - name\n         * - id\n         * - for\n         * - href\n         * - data-fieldname\n         *\n         * On the server side, the DGF logic will rebuild rows based\n         * on this information.\n         *\n         * If indexing for some reasons fails you'll get double\n         * input values and Zope converts inputs to list, failing\n         * in funny ways.\n         *\n         * @param  {DOM} row\n         * @param  {Number} new_index\n         */\n\n        var name_prefix = this.el_body.dataset.name_prefix + \".\";\n        var id_prefix = this.el_body.dataset.id_prefix + \"-\";\n        var old_index = row.dataset.oldIndex || row.dataset.index;\n        delete row.dataset.oldIndex;\n\n        function replaceIndex(el, attr, prefix) {\n            var val = el.getAttribute(attr);\n            if (val) {\n                var pattern = new RegExp(\"^\" + prefix + old_index);\n                el.setAttribute(\n                    attr,\n                    val.replace(pattern, prefix + new_index)\n                );\n            }\n        }\n\n        row.dataset.index = new_index; // update index data\n\n        row.querySelectorAll('[id^=\"formfield-' + id_prefix + '\"]').forEach(function (el) {\n            replaceIndex(el, \"id\", \"formfield-\" + id_prefix);\n        }, this); // prettier-ignore\n        row.querySelectorAll('[name^=\"' + name_prefix + '\"]').forEach(function (el) {\n            replaceIndex(el, \"name\", name_prefix);\n        }, this); // prettier-ignore\n        row.querySelectorAll('[id^=\"' + id_prefix + '\"]').forEach(function (el) {\n            replaceIndex(el, \"id\", id_prefix);\n        }, this); // prettier-ignore\n        row.querySelectorAll('[for^=\"' + id_prefix + '\"]').forEach(function (el) {\n            replaceIndex(el, \"for\", id_prefix);\n        }, this); // prettier-ignore\n        row.querySelectorAll('[href*=\"#' + id_prefix + '\"]').forEach(function (el) {\n            replaceIndex(el, \"href\", \"#\" + id_prefix);\n        }, this); // prettier-ignore\n        row.querySelectorAll('[data-fieldname^=\"' + name_prefix + '\"]').forEach(function (el) {\n            replaceIndex(el, \"data-fieldname\", name_prefix);\n        }, this); // prettier-ignore\n    },\n\n    updateOrderIndex: function () {\n        /**\n         * Update all row indexes on a DGF table.\n         *\n         * Each <tr> and input widget has recalculated row index number in its name,\n         * so that the server can then parsit the submitted data in the correct order.\n         */\n\n        var cnt = 0;\n        var rows = this.getRows();\n        rows.forEach(function (row) {\n            var index = row.dataset.index;\n            if ([\"AA\", \"TT\"].indexOf(index) > -1) {\n                this.reindexRow(row, index);\n                return;\n            }\n            this.reindexRow(row, cnt);\n            row.dataset.index = cnt;\n            cnt++; // we start counting with \"0\"\n        }, this);\n\n        var name_prefix = this.el_body.dataset.name_prefix + \".\";\n        var count_el = this.el.querySelector(\n            'input[name=\"' + name_prefix + 'count\"]'\n        );\n        count_el.value = this.countRows();\n\n        this.setUIState();\n    },\n\n    getParentRow: function (node) {\n        var parent = node.closest(\".datagridwidget-row\");\n        if (parent) {\n            return parent;\n        }\n        return null;\n    },\n\n    ensureMinimumRows: function () {\n        /**\n         * Make sure there is at least one visible row available in DGF\n         * to edit in all the time.\n         *\n         * We need a lot of special logic for the case where\n         * we have empty datagridfield and need to have one OPTIONAL\n         * row present there for the editing when the user opens\n         * the form for the first time.\n         *\n         * There are cases where one doesn't want to have the count of DGF\n         * rows to go down to zero. Otherwise there no insert handle left\n         * on the edit mode and the user cannot add any more rows.\n         *\n         * One should case is when\n         *\n         * - DGF is empty on new form\n         *\n         * - Auto append is set to false (initial row is not visible)\n         *\n         * We fix this situation by checking the available rows\n         * and generating one empty AA row if needed.\n         *\n         * ... or simply when the user removes all the rows\n         */\n\n        var rows = this.getRows();\n        var filteredRows = this.getVisibleRows();\n\n        // Rows = 0 -> make one AA row available\n        if (rows.length && filteredRows.length === 0) {\n            this.auto_append_row();\n            return true;\n        }\n        return false;\n    },\n\n});\n","import registry from \"@patternslib/patternslib/src/core/registry\";\nimport \"./js/datagridfield.pattern\";\n\nregistry.init();\n"],"names":["logging","setLevel","getLogger","Base","extend","name","trigger","parser","init","this","el","$el","el_body","querySelector","auto_append","dataset","autoAppend","toLowerCase","_defineHandler","getVisibleRows","forEach","row","initRowUI","ensureMinimumRows","updateOrderIndex","initAutoAppendHandler","dispatchEvent","Event","bubbles","cancelable","handler_auto_append","e","stopPropagation","target","closest","auto_append_row","bind","handler_auto_append_input","currentTarget","classList","remove","oldIndex","index","removeEventListener","querySelectorAll","addEventListener","preventDefault","insertRow","removeFieldRow","moveRowUp","moveRowDown","get_row_buttons","add","delete","up","down","setUIState","rows","cnt","length","buttons","disabled","before_aa_buttons","getRows","getLastRow","getLastVisibleRow","result","countRows","count","indexOf","last_row","new_row","reindexRow","ref_row","before","newtr","createNewRow","$newtr","$","insertBefore","insertAfter","Registry","scan","template_row","Error","document","createElement","innerHTML","outerHTML","find","attr","i","cls","replace","moveRow","moveRowToTop","moveRowToBottom","insert_after","each","_row","direction","nextRow","idx","validrows","shiftRow","parseInt","bottom","top","new_index","name_prefix","id_prefix","old_index","replaceIndex","prefix","val","getAttribute","pattern","RegExp","setAttribute","value","getParentRow","node","parent","filteredRows","registry"],"sourceRoot":""}