/*global window, console*/

require([
    'jquery',
    'pat-registry',
  ], function ($, patRegistry) {

      // No globals, dude!
      "use strict";

      // Local singleton object containing our functions
      var dataGridField2Functions = {};

      dataGridField2Functions.getInputOrSelect = function(node) {
          /* Get the (first) input or select form element under the given node */
          var inputs = node.getElementsByTagName("input");
          if(inputs.length > 0) {
              return inputs[0];
          }
          var selects = node.getElementsByTagName("select");
          if(selects.length > 0) {
              return selects[0];
          }
          return null;
      };

      dataGridField2Functions.getWidgetRows = function(currnode) {
          /* Return primary nodes with class of datagridwidget-row,
             they can be any tag: tr, div, etc. */
          var tbody = this.getParentByClass(currnode, "datagridwidget-body");
          return this.getRows(tbody);
      };

      dataGridField2Functions.getRows = function(tbody) {
          /* Return primary nodes with class of datagridwidget-row,
             they can be any tag: tr, div, etc. */
          var rows = $(tbody).children('.datagridwidget-row');
          return rows;
      };


      /**
       * Get all visible rows of DGF
       *
       * Incl. normal rows + AA row
       */
      dataGridField2Functions.getVisibleRows = function(tbody) {
          var rows = this.getRows(tbody);
          // We rape jQuery.filter here, because of
          // IE8 Array.filter http://kangax.github.com/es5-compat-table/

          // Consider "real" rows only
          var filteredRows = $(rows).filter(function() {
              var $tr = $(this);
              return !$tr.hasClass("datagridwidget-empty-row");
          });
          return filteredRows;
      };

      /**
       * Handle auto insert events by auto append
       */
      dataGridField2Functions.onInsert = function(e) {
          var currnode = e.currentTarget;
          this.autoInsertRow(currnode);
      },

      /**
       * Add a new row when changing the last row
       *
       * @param {Boolean} ensureMinimumRows we insert a special minimum row so the widget is not empty
       */
      dataGridField2Functions.autoInsertRow = function(currnode, ensureMinimumRows) {
          // fetch required data structure
          var dgf = $(dataGridField2Functions.getParentByClass(currnode, "datagridwidget-table-view"));
          var tbody = dataGridField2Functions.getParentByClass(currnode, "datagridwidget-body");
          var thisRow = dataGridField2Functions.getParentRow(currnode); // The new row we are working on
          var $thisRow = $(thisRow);
          var autoAppendMode = $(tbody).data("auto-append");

          if($thisRow.hasClass("minimum-row")) {
              // The change event was not triggered on real AA row,
              // but on a minimum ensured row (row 0).
              // 1. Don't add new row
              // 2. Make widget to "normal" state now as the user has edited the empty row so we assume it's a real row
              this.supressEnsureMinimum(tbody);
              return;
          }

          // Remove the auto-append functionality from the all rows in this widget
          var autoAppendHandlers = dgf.find('.auto-append .datagridwidget-cell, .auto-append .datagridwidget-block-edit-cell');
          autoAppendHandlers.unbind('change.dgf');
          $thisRow.removeClass('auto-append');

          // Create a new row
          var newtr = dataGridField2Functions.createNewRow(thisRow), $newtr = $(newtr);
          // Add auto-append functionality to our new row
          $newtr.addClass('auto-append');

          /* Put new row to DOM tree after our current row.  Do this before
           * reindexing to ensure that any Javascript we insert that depends on
           * DOM element IDs (such as plone.formwidget.autocomplete) will
           * pick up this row before any IDs get changed.  At this point,
           * we techinically have duplicate TT IDs in our document
           * (one for this new row, one for the hidden row), but jQuery
           * selectors will pick up elements in this new row first.
           */

          dgf.trigger("beforeaddrowauto", [dgf, newtr]);

          if(ensureMinimumRows) {
              // Add a special class so we can later deal with it
              $newtr.addClass("minimum-row");
              $newtr.insertBefore(thisRow);
          } else {
              $newtr.insertAfter(thisRow);
          }

          // Re-enable auto-append change handler feature on the new auto-appended row
          $(dgf).find('.auto-append .datagridwidget-cell, .auto-append .datagridwidget-block-edit-cell').bind("change.dgf", $.proxy(dataGridField2Functions.onInsert, dataGridField2Functions));
          dataGridField2Functions.reindexRow(tbody, newtr, 'AA');

          // Update order index to give rows correct values
          dataGridField2Functions.updateOrderIndex(tbody, true, ensureMinimumRows);
          dgf.trigger("afteraddrowauto", [dgf, newtr]);
      };

      /**
       * Creates a new row after the the target row.
       *
       * @param {Object} currnode DOM <tr>
       */
      dataGridField2Functions.addRowAfter = function(currnode) {
          // fetch required data structure
          var tbody = this.getParentByClass(currnode, "datagridwidget-body");
          var dgf = $(dataGridField2Functions.getParentByClass(currnode, "datagridwidget-table-view"));
          var thisRow = this.getParentRow(currnode);
          var newtr = this.createNewRow(thisRow);
          dgf.trigger("beforeaddrow", [dgf, newtr]);
          var filteredRows = this.getVisibleRows(currnode);

          // If using auto-append we add the "real" row before AA
          // We have a special case when there is only one visible in the gid
          if (thisRow.hasClass('auto-append') && !thisRow.hasClass("minimum-row")) {
              $(newtr).insertBefore(thisRow);
          } else {
              $(newtr).insertAfter(thisRow);
          }

          // Ensure minimum special behavior is no longer needed as we have now at least 2 rows
          if(thisRow.hasClass("minimum-row")) {
              this.supressEnsureMinimum(tbody);
          }

          // update orderindex hidden fields
          this.updateOrderIndex(tbody, true);
          dgf.trigger("afteraddrow", [dgf, newtr]);
      };
      /**
       * Copys the current row after the target row.
       *
       * @param {Object} currnode DOM <tr>
       */
      dataGridField2Functions.duplicateRowAfter = function(currnode) {
          // fetch required data structure
          var tbody = this.getParentByClass(currnode, "datagridwidget-body");
          var dgf = $(dataGridField2Functions.getParentByClass(currnode, "datagridwidget-table-view"));
          var thisRow = this.getParentRow(currnode);
          var filteredRows = this.getVisibleRows(currnode);

          // find all select2 and destroy them
          // https://stackoverflow.com/a/17381913
          var all_select2 = thisRow.find(".pat-select2");
          for (let i = 0; i < all_select2.length; i++) {
                $(all_select2[i]).select2('destroy');
          }
          //clone the row
          var duplicatedRow = thisRow.clone();
          dgf.trigger("beforeaddrow", [dgf, duplicatedRow]);

          // If using auto-append we add the "real" row before AA
          // We have a special case when there is only one visible in the gid
          if (thisRow.hasClass('auto-append') && !thisRow.hasClass("minimum-row")) {
              $(duplicatedRow).insertBefore(thisRow);
          } else {
              $(duplicatedRow).insertAfter(thisRow);
          }

          // Ensure minimum special behavior is no longer needed as we have now at least 2 rows
          if(thisRow.hasClass("minimum-row")) {
              this.supressEnsureMinimum(tbody);
          }

          // update orderindex hidden fields
          this.updateOrderIndex(tbody, true);
          dgf.trigger("afteraddrow", [dgf, duplicatedRow]);

          //we must have to re-initialize select2
          let existingRowSelects = thisRow.find(".pat-select2");
          for (let i = 0; i < existingRowSelects.length; i++) {
                $(existingRowSelects[i]).select2();
          }
          let duplicatedRowSelects = duplicatedRow.find(".pat-select2");
          for (let i = 0; i < existingRowSelects.length; i++) {
                $(duplicatedRowSelects[i]).select2();
          }
      };

      /**
       * Creates a new row.
       *
       * The row is not inserted to the table, but is returned.
       *
       * @param {Object} <tr> or <tbody> DOM node in a table where we'll be adding the new row
       */
      dataGridField2Functions.createNewRow = function(node) {
          var tbody = this.getParentByClass(node, "datagridwidget-body");
          // hidden template row
          var emptyRow = $(tbody).children('.datagridwidget-empty-row').first();
          if(emptyRow.size() === 0) {
              // Ghetto assert()
              throw new Error("Could not locate empty template row in DGF");
          }
          var new_row = emptyRow.clone(true).removeClass('datagridwidget-empty-row');

          // enable patternslib
          $(new_row).find('*[class^="dgw-disabled-pat-"]')
          .attr('class', function(i, cls) {
            return cls.replace(/dgw\-disabled-pat-/, 'pat-');
          });
          patRegistry.scan(new_row);
          return new_row;
      };


      dataGridField2Functions.removeFieldRow = function(node) {
          /* Remove the row in which the given node is found */
          var tbody = this.getParentByClass(node, "datagridwidget-body");
          var row = this.getParentRow(node);
          $(row).remove();
          // ensure minimum rows in non-auto-append mode, reindex if no
          // minimal row was added, otherwise reindexing is done by ensureMinimumRows
          if ($(tbody).data("auto-append") || !this.ensureMinimumRows(tbody)) {
              this.updateOrderIndex(tbody, false);
          }
      };

      dataGridField2Functions.moveRow = function(currnode, direction){
          /* Move the given row down one */
          var nextRow;
          var dgf = $(dataGridField2Functions.getParentByClass(currnode, "datagridwidget-table-view"));
          var tbody = this.getParentByClass(currnode, "datagridwidget-body");
          var rows = this.getWidgetRows(currnode);
          var row = this.getParentRow(currnode);
          if(!row) {
              throw new Error("Couldn't find DataGridWidget row");
          }
          var idx = null;

          // We can't use nextSibling because of blank text nodes in some browsers
          // Need to find the index of the row
          rows.each(function (i) {
              if (this == row[0]) {
                  idx = i;
              }
          });

          // Abort if the current row wasn't found
          if (idx == null)
              return;

          // The up and down should cycle through the rows, excluding the auto-append and
          // empty-row rows.
          var validrows = 0;
          rows.each(function (i) {
              if (!$(this).hasClass('datagridwidget-empty-row') && !$(this).hasClass('auto-append')) {
                  validrows+=1;
              }
          });

          if (idx+1 == validrows) {
              if (direction == "down") {
                  this.moveRowToTop(row);
              } else {
                  nextRow = rows[idx-1];
                  this.shiftRow(nextRow, row);
              }
          } else if (idx === 0) {
              if (direction == "up") {
                  this.moveRowToBottom(row);
              } else {
                  nextRow = rows[parseInt(idx+1, 10)];
                  this.shiftRow(row, nextRow);
              }
          } else {
              if (direction == "up") {
                  nextRow = rows[idx-1];
                  this.shiftRow(nextRow, row);
              } else {
                  nextRow = rows[parseInt(idx+1, 10)];
                  this.shiftRow(row, nextRow);
              }
          }
          this.updateOrderIndex(tbody);
          dgf.trigger("aftermoverow", [dgf, row]);
      };

      dataGridField2Functions.moveRowDown = function(currnode){
          this.moveRow(currnode, "down");
      };

      dataGridField2Functions.moveRowUp = function(currnode){
          this.moveRow(currnode, "up");
      };

      dataGridField2Functions.shiftRow = function(bottom, top){
          /* Put node top before node bottom */
          $(top).insertBefore(bottom);
      };

      dataGridField2Functions.moveRowToTop = function (row) {
          var rows = this.getWidgetRows(row);
          $(row).insertBefore(rows[0]);
      };

      dataGridField2Functions.moveRowToBottom = function (row) {
          var rows = this.getWidgetRows(row);

          // make sure we insert the directly above any auto appended rows
          var insert_after = 0;
          rows.each(function (i) {
              if (!$(this).hasClass('datagridwidget-empty-row')  && !$(this).hasClass('auto-append')) {
                  insert_after = i;
              }
          });
          $(row).insertAfter(rows[insert_after]);
      };

      /**
       * Fixup all attributes on all child elements that contain
       * the row index. The following attributes are scanned:
       * - name
       * - id
       * - for
       * - href
       * - data-fieldname
       *
       * On the server side, the DGF logic will rebuild rows based
       * on this information.
       *
       * If indexing for some reasons fails you'll get double
       * input values and Zope converts inputs to list, failing
       * in funny ways.
       *
       * @param  {DOM} tbody
       * @param  {DOM} row
       * @param  {Number} newindex
       */
      dataGridField2Functions.reindexRow = function (tbody, row, newindex) {
          var name_prefix = $(tbody).data('name_prefix') + '.';
          var id_prefix = $(tbody).data('id_prefix') + '-';
          var $row = $(row);
          var oldindex = $row.data('index');

          function replaceIndex(el, attr, prefix) {
              if (el.attr(attr)) {
                  var val = el.attr(attr);
                  var pattern = new RegExp('^' + prefix + oldindex);
                  el.attr(attr, val.replace(pattern, prefix + newindex));
                  if (attr.indexOf('data-') === 0) {
                      var key = attr.substr(5);
                      var data = el.data(key);
                      el.data(key, data.replace(pattern, prefix + newindex));
                  }
              }
          }

          // update index data
          $row.data('index', newindex);
          $row.attr('data-index', newindex);

          $row.find('[id^="formfield-' + id_prefix + '"]').each(function(i, el) {
              replaceIndex($(el), 'id', 'formfield-' + id_prefix);
          });
          $row.find('[name^="' + name_prefix +'"]').each(function(i, el) {
              replaceIndex($(el), 'name', name_prefix);
          });
          $row.find('[id^="' + id_prefix +'"]').each(function(i, el) {
              replaceIndex($(el), 'id', id_prefix);
          });
          $row.find('[for^="' + id_prefix +'"]').each(function(i, el) {
              replaceIndex($(el), 'for', id_prefix);
          });
          $row.find('[href*="#' + id_prefix +'"]').each(function(i, el){
              replaceIndex($(el), 'href', '#' + id_prefix);
          });
          $row.find('[data-fieldname^="' + name_prefix + '"]').each(function(i, el) {
              replaceIndex($(el), 'data-fieldname', name_prefix);
          });
      };

      /**
       * Stop ensure miminum special behavior.
       *
       * The caller is responsible to check there was one and only one minimum-row in the table.
       *
       * Call when data is edited for the first time or a row added.
       */
      dataGridField2Functions.supressEnsureMinimum = function(tbody) {
          var autoAppendHandlers = $(tbody).find('.auto-append .datagridwidget-cell, .auto-append .datagridwidget-block-edit-cell');
          autoAppendHandlers.unbind('change.dgf');
          tbody.children().removeClass("auto-append");
          tbody.children().removeClass("minimum-row");
          dataGridField2Functions.updateOrderIndex(tbody, true, false);
      };

      /**
       * Update all row indexes on a DGF table.
       *
       * Each <tr> and input widget has recalculated row index number in its name,
       * so that the server can then parsit the submitted data in the correct order.
       *
       * @param  {Object} tbody     DOM of DGF <tbody>
       * @param  {Boolean} backwards iterate rows backwards
       * @param  {Boolean} ensureMinimumRows We have inserted a special auto-append row
       */
      dataGridField2Functions.updateOrderIndex = function (tbody, backwards, ensureMinimumRows) {
          var $tbody = $(tbody);
          var name_prefix = $tbody.attr('data-name_prefix') + '.';
          var i, idx, row, $row, $nextRow;

          // Was this auto-append table
          var autoAppend = false;
          var rows = this.getRows(tbody);
          for (i=0; i<rows.length; i++) {
              idx = backwards ? rows.length-i-1 : i;
              row = rows[idx], $row = $(row);

              if ($row.hasClass('datagridwidget-empty-row')) {
                  continue;
              }
              if($row.hasClass('auto-append')) {
                  autoAppend = true;
              }
              this.reindexRow(tbody, row, idx);
          }

          // Handle a special case where
          // 1. Widget is empty
          // 2. We don't have AA mode turned on
          // 3. We need to have minimum editable row count of 1
          if(ensureMinimumRows) {
              this.reindexRow(tbody, rows[0], "AA");
              autoAppend = true;
          }

          // Add a special first and class row classes
          // to hide manipulation handles
          // AA handling is different once again
          var visibleRows = this.getVisibleRows(tbody);
          for (i=0; i<visibleRows.length; i++) {
              row = visibleRows[i], $row = $(row);
              if(i<visibleRows.length-2) {
                  $nextRow = $(visibleRows[i+1]);
              }
              if(i===0) {
                  $row.addClass("datagridfield-first-filled-row");
              } else {
                  $row.removeClass("datagridfield-first-filled-row");
              }
              // Last visible before AA
              if(autoAppend) {
                  if($nextRow && $nextRow.hasClass("auto-append")) {
                      $row.addClass("datagridfield-last-filled-row");
                  } else {
                      $row.removeClass("datagridfield-last-filled-row");
                  }
              } else {
                  if(i==visibleRows.length-1) {
                      $row.addClass("datagridfield-last-filled-row");
                  } else {
                      $row.removeClass("datagridfield-last-filled-row");
                  }
              }
          }

          // Set total visible row counts and such and hint CSS
          var vis = this.getVisibleRows(tbody).length;
          $tbody.attr("data-count", this.getRows(tbody).length);
          $tbody.attr("data-visible-count", this.getVisibleRows(tbody).length);
          $tbody.attr("data-many-rows", vis >= 2 ? "true" : "false");

          $(document).find('input[name="' + name_prefix + 'count"]').each(function(){
              // do not include the TT and the AA rows in the count
              var count = rows.length;
              if ($(rows[count-1]).hasClass('datagridwidget-empty-row')) {
                  count--;
              }
              if ($(rows[count-1]).hasClass('auto-append')) {
                  count--;
              }
              this.value = count;
          });
      };

      dataGridField2Functions.getParentElement = function(currnode, tagname) {
          /* Find the first parent node with the given tag name */
          tagname = tagname.toUpperCase();
          var parent = currnode.parentNode;
          while(parent.tagName.toUpperCase() != tagname) {
              parent = parent.parentNode;
              // Next line is a safety belt
              if(parent.tagName.toUpperCase() == "BODY")
                  return null;
          }
          return parent;
      };

      dataGridField2Functions.getParentRow = function (node) {
          return this.getParentByClass(node, 'datagridwidget-row');
      };

      dataGridField2Functions.getParentByClass = function(node, klass) {
          var parent = $(node).closest("." + klass);

          if (parent.length) {
              return parent;
          }

          return null;
      };

      /**
       * Find the first parent node with the given id
       *
       * Id is partially matched: the beginning of
       * an element id matches parameter id string.
       *
       * @param  {DOM} currnode Node where ascending in DOM tree beings
       * @param  {String} id       Id string to look for.
       * @return {DOM} Found node or null
       */
      dataGridField2Functions.getParentElementById = function(currnode, id) {
          /*
          */

          id = id.toLowerCase();
          var parent = currnode.parentNode;

          while(true) {

              var parentId = parent.getAttribute("id");
              if(parentId) {
                   if(parentId.toLowerCase().substring(0, id.length) == id) break;
              }

              parent = parent.parentNode;
              // Next line is a safety belt
              if(parent.tagName.toUpperCase() == "BODY")
                  return null;
          }

          return parent;
      };


      /**
       * Make sure there is at least one visible row available in DGF
       * to edit in all the time.
       *
       * We need a lot of special logic for the case where
       * we have empty datagridfield and need to have one OPTIONAL
       * row present there for the editing when the user opens
       * the form for the first time.
       *
       * There are cases where one doesn't want to have the count of DGF
       * rows to go down to zero. Otherwise there no insert handle left
       * on the edit mode and the user cannot add any more rows.
       *
       * One should case is when
       *
       * - DGF is empty on new form
       *
       * - Auto append is set to false (initial row is not visible)
       *
       * We fix this situation by checking the available rows
       * and generating one empty AA row if needed.
       *
       * ... or simply when the user removes all the rows
       *
       * @param {Object} tbody DOM object of <tbody>
       */
      dataGridField2Functions.ensureMinimumRows = function(tbody) {
          var rows = this.getRows(tbody);
          var filteredRows = this.getVisibleRows(tbody);
          var self = this;

          // Rows = 0 -> make one AA row available
          if(filteredRows.length === 0) {
              // XXX: make the function call signatures more sane
              var child = rows[0];
              this.autoInsertRow(child, true);
              return true;
          }
          return false;
      },


      /**
       * When DOM model is ready execute this actions to wire up page logic.
       */
      dataGridField2Functions.init = function() {

          // Reindex all rows to get proper row classes on them
          $(".datagridwidget-body").each(function() {

              // Initialize widget data on <tbody>
              // We keep some mode attributes around
              var $this = $(this);
              var aa;

              // Check if this widget is in auto-append mode
              // and store for later usage
              aa = $this.children(".auto-append").size() > 0;
              $this.data("auto-append", aa);

              // Hint CSS
              if(aa) {
                  $this.addClass("datagridwidget-body-auto-append");
              } else {
                  $this.addClass("datagridwidget-body-non-auto-append");
              }

              dataGridField2Functions.updateOrderIndex(this, false);

              if(!aa) {
                  dataGridField2Functions.ensureMinimumRows(this);
              }
          });

          // Bind the handlers to the auto append rows
          // Use namespaced jQuery events to avoid unbind() conflicts later on
          $('.auto-append .datagridwidget-cell, .auto-append .datagridwidget-block-edit-cell').bind("change.dgf", $.proxy(dataGridField2Functions.onInsert, dataGridField2Functions));

          $(document).trigger("afterdatagridfieldinit");
      };

      // Export module for customizers to mess around
      window.dataGridField2Functions = dataGridField2Functions;


  });
